<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Description_20221219" xml:space="preserve">
    <value>Add the ability to export PDFs</value>
  </data>
  <data name="Description_20221226" xml:space="preserve">
    <value>Fixed some bugs; Add a changelog</value>
  </data>
  <data name="Description_20230109" xml:space="preserve">
    <value>Added duplicate book search function</value>
  </data>
  <data name="Description_20230125" xml:space="preserve">
    <value>Reading page full-screen functionality; default bookshelf</value>
  </data>
  <data name="Description_20230205" xml:space="preserve">
    <value>Optimized startup speed</value>
  </data>
  <data name="Description_before" xml:space="preserve">
    <value>Older records</value>
  </data>
  <data name="Version_20221219" xml:space="preserve">
    <value>2022.12.19</value>
  </data>
  <data name="Version_20221226" xml:space="preserve">
    <value>2022.12.26</value>
  </data>
  <data name="Version_20230109" xml:space="preserve">
    <value>2023.01.09</value>
  </data>
  <data name="Version_20230125" xml:space="preserve">
    <value>2023.01.25</value>
  </data>
  <data name="Version_20230205" xml:space="preserve">
    <value>2023.2.5</value>
  </data>
  <data name="Version_before" xml:space="preserve">
    <value>Earlier versions</value>
  </data>
  <data name="Question_WhyZipRatherFolder" xml:space="preserve">
    <value>Why use a compressed format instead of folders</value>
  </data>
  <data name="Answer_SupportedType" xml:space="preserve">
    <value>Zip and 7z. For saving books,Zip is the best choice.。 Other formats (e.g., RAR, 7Z) are of course possible, but they are not optimal. ZIP format is a free and open source compressed archive format, Windows built-in support for ZIP, with good decompression speed and compression rate.</value>
  </data>
  <data name="Answer_WhatISTheApp" xml:space="preserve">
    <value>This is a software used to manage the compressed format of the book of the local collection.。 If you don't know what a book is,Then there's a high probability you won't use this software.。</value>
  </data>
  <data name="Answer_WhyZipRatherFolder" xml:space="preserve">
    <value>With folders, there will be a large number of scattered individual picture files. A large number of scattered files and their difficulty in managing (e.g. copying and pasting slows down the system) and are also conducive to collections.</value>
  </data>
  <data name="Question_SupportedType" xml:space="preserve">
    <value>Supported types</value>
  </data>
  <data name="Question_WhatISTheApp" xml:space="preserve">
    <value>What kind of software is it?</value>
  </data>
  <data name="Answer_MangaLibrary" xml:space="preserve">
    <value>Separate management of the doujinshi according to its folder</value>
  </data>
  <data name="Answer_Tag" xml:space="preserve">
    <value>This Tag is read from the doujinshi. For example, in the file "[Jade Sugar] キミ色保護色 (COMIC BAVEL June 2021 issue) [無邪気漢化組] [無邪気無無universe分組] [MJK-22-Z2748] [無amendment].zip], in this software, content contained in a pair of parentheses will be recognized as a Tag, and content not included in parentheses will be recognized as this doujinshi. This is not necessarily 100% correctly identifiable.</value>
  </data>
  <data name="Question_MangaLibrary" xml:space="preserve">
    <value>This doujinshi-library</value>
  </data>
  <data name="Question_Tag" xml:space="preserve">
    <value>Tag</value>
  </data>
</root>